> shell多线程
> 转发自：https://blog.csdn.net/lyf0327/article/details/83997847
```
#!/bin/bash
start_time=`date +%s` #定义脚本运行的开始时间
[ -e /tmp/fd1 ] || mkfifo /tmp/fd1 #创建有名管道
exec 3<>/tmp/fd1 #创建文件描述符，以可读（<）可写（>）的方式关联管道文件，这时候文件描述符3就有了有名管道文件的所有特性
rm -rf /tmp/fd1 #关联后的文件描述符拥有管道文件的所有特性,所以这时候管道文件可以删除，我们留下文件描述符来用就可以了
for ((i=1;i<=10;i++))
do
echo >&3 #&3代表引用文件描述符3，这条命令代表往管道里面放入了一个"令牌"
done

for ((i=1;i<=1000;i++))
do
read -u3 #代表从管道中读取一个令牌
{
sleep 1 #sleep 1用来模仿执行一条命令需要花费的时间（可以用真实命令来代替）
echo ‘success’$i
echo >&3 #代表我这一次命令执行到最后，把令牌放回管道
}&
done
wait

stop_time=`date +%s` #定义脚本运行的结束时间

echo “TIME:`expr $stop_time - $start_time`”
exec 3<&- #关闭文件描述符的读
exec 3>&- #关闭文件描述符的写
-----------------------------------------------------------------------
代码解析以及问题：

两个for循环，第一个for循环10次，相当于在女士公共厕所门口放了10把钥匙，第二个for

循环1000次，相当于1000个人来上厕所，read -u3相当于取走一把药匙，{}里面最后一行代码echo >&3相当于上完厕所送还药匙。

这样就实现了10把药匙控制1000个任务的运行，运行时间为101s，肯定不如方案二快，但是比方案一已经快很多了，这就是队列控制同一时间只有最多10个线程的并发，既提高了效率，又实现了并发控制。

注意：创建一个文件描述符exec 3<>/tmp/fd1 不能有空格，代表文件描述符3有可读（<）可写（>）权限，注意，打开的时候可以写在一起，关闭的时候必须分开关，exec 3<&-关闭读，exec 3>&-关闭写
```